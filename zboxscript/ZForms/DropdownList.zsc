class boxparty_DropdownItems {
	Array<string> items;
}

class boxparty_DropdownList : boxparty_Element {
	boxparty_DropdownItems items;
	int selection;
	int textColor;
	Font fnt;
	double textScale;

	boxparty_Frame bindingFrame;

	boxparty_BoxTextures boxBg;
	boxparty_BoxDrawer boxBgDrawer;
	boxparty_BoxTextures listBg;
	boxparty_BoxDrawer listBgDrawer;
	boxparty_BoxTextures highlightBg;
	boxparty_BoxDrawer highlightBgDrawer;
	string dropTex;

	protected bool clicking;
	protected bool active;
	protected int hover;

	void config(
		boxparty_DropdownItems items, Font fnt = NULL, double textScale = 1.0, int textColor = Font.CR_WHITE,
		boxparty_BoxTextures boxBg = NULL, boxparty_BoxTextures listBg = NULL, boxparty_BoxTextures highlightBg = NULL,
		string dropTex = "", int defaultSelection = -1, boxparty_Handler cmdHandler = NULL, string command = "",
		boxparty_Frame bindingFrame = NULL
	) {
		if (fnt == NULL) {
			self.fnt = smallfont;
		}
		else {
			self.fnt = fnt;
		}
		self.items = items;
		self.selection = defaultSelection;
		self.textScale = textScale;
		self.textColor = textColor;
		self.boxBg = boxBg;
		self.listBg = listBg;
		self.highlightBg = highlightBg;
		self.dropTex = dropTex;
		self.cmdHandler = cmdHandler;
		self.command = command;
		self.bindingFrame = bindingFrame;
		self.alpha = 1.0;
	}

	static boxparty_DropdownList create(
		Vector2 pos, Vector2 size,
		boxparty_DropdownItems items, Font fnt = NULL, double textScale = 1.0, int textColor = Font.CR_WHITE,
		boxparty_BoxTextures boxBg = NULL, boxparty_BoxTextures listBg = NULL, boxparty_BoxTextures highlightBg = NULL,
		string dropTex = "", int defaultSelection = -1, boxparty_Handler cmdHandler = NULL, string command = "",
		boxparty_Frame bindingFrame = NULL
	) {
		let ret = new("boxparty_DropdownList");

		ret.config(
			items, fnt, textScale, textColor, boxBg, listBg, highlightBg, dropTex,
			defaultSelection, cmdHandler, command, bindingFrame
		);
		ret.setBox(pos, size);

		return ret;
	}

	override bool blocksMouse(Vector2 mousePos) {
		boxparty_AABB screenBox; boxToScreen(screenBox);
		return screenBox.pointCollides(mousePos);
	}

	void dropdownAABB(boxparty_AABB screenBox) {
		boxparty_AABB aabb;
		aabb.pos = (0.0, getDropdownYOff());
		aabb.size = (box.size.x, box.size.y * items.items.size());
		aabbToScreen(screenBox, aabb, false);
		if (bindingFrame != NULL) {
			boxparty_AABB bindingBox; bindingFrame.boxToScreen(bindingBox);
			screenBox.rectOfIntersection(screenBox, bindingBox);
		}
	}

	override bool blocksMousePriority(Vector2 mousePos) {
		if (!active) return false;
		boxparty_AABB screenBox; dropdownAABB(screenBox);
		return screenBox.pointCollides(mousePos);
	}

	override void drawer() {
		boxparty_AABB beforeClip, clipRect;
		screenClip(beforeClip, clipRect);
		Screen.setClipRect(int(clipRect.pos.x), int(clipRect.pos.y), int(clipRect.size.x), int(clipRect.size.y));

		if (clicking) {
			if (highlightBg) highlightBgDrawer.draw(self, (0, 0), box.size, highlightBg, true);
		} else if (boxBg) {
			boxBgDrawer.draw(self, (0, 0), box.size, boxBg, true);
		}
		if (selection != -1) {
			let text = items.items[selection];
			Vector2 pos = getAlignedDrawPos(box.size, (fnt.stringWidth(text), fnt.getHeight()) * textScale, AlignType_CenterLeft);
			drawText(pos + (4.0 * textScale, 0.0), fnt, text, textColor, textScale);
		}
		TextureID dropTexID = TexMan.checkForTexture(dropTex, TexMan.Type_Any);
		if (dropTexID) {
			let dropSize = TexMan.getScaledSize(dropTexID);
			let dropPos = (box.size.x - box.size.y / 2.0, box.size.y / 2.0) - dropSize / 2.0;
			drawImage(dropPos, dropTex, true, (1.0, 1.0));
		}

		Screen.setClipRect(int(beforeClip.pos.x), int(beforeClip.pos.y), int(beforeClip.size.x), int(beforeClip.size.y));
	}

	double getDropdownYOff() {
		boxparty_AABB aabb;
		aabb.pos = (0.0, box.size.y);
		aabb.size = (box.size.x, box.size.y * items.items.size());
		boxparty_AABB dropdownBox; aabbToScreen(dropdownBox, aabb, false);
		boxparty_AABB masterBox;
		if (bindingFrame != NULL) {
			bindingFrame.boxToScreen(masterBox);
		}
		else {
			masterBox.size.x = Screen.getWidth();
			masterBox.size.y = Screen.getHeight();
		}
		if (dropdownBox.pos.y + dropdownBox.size.y > masterBox.pos.y + masterBox.size.y) {
			aabb.pos.y = -box.size.y * items.items.size();
			aabbToScreen(dropdownBox, aabb, false);
			if (dropdownBox.pos.y < masterBox.pos.y) {
				return -box.size.y * items.items.size() + (masterBox.pos.y - dropdownBox.pos.y) / getScale();
			}
			else {
				return -box.size.y * items.items.size();
			}
		}
		else {
			return box.size.y;
		}
	}

	override void topDrawer() {
		if (!active) return;

		boxparty_AABB screenBox; dropdownAABB(screenBox);
		hover = -1;
		if (screenBox.pointCollides(master.mousePos)) {
			let diff = master.mousePos - screenBox.pos;
			diff /= getScale();
			int newSelection = int(diff.y / box.size.y);
			hover = newSelection;
		}

		boxparty_AABB beforeClip, clipRect;
		if (bindingFrame != NULL) {
			bindingFrame.screenClip(beforeClip, clipRect);
			Screen.setClipRect(int(clipRect.pos.x), int(clipRect.pos.y), int(clipRect.size.x), int(clipRect.size.y));
		}
		else {
			screenClip(beforeClip, clipRect);
			Screen.clearClipRect();
		}

		if (listBg) {
			listBgDrawer.draw(self, (0, getDropdownYOff()), (box.size.x, box.size.y * items.items.size()), listBg, true);
		}
		if (hover != -1 && highlightBg) {
			highlightBgDrawer.draw(self, (0, getDropdownYOff() + box.size.y * hover), (box.size.x, box.size.y), highlightBg, true);
		}
		for (int i = 0; i < items.items.size(); i++) {
			let text = items.items[i];
			Vector2 pos = getAlignedDrawPos(box.size, (fnt.stringWidth(text), fnt.getHeight()) * textScale, AlignType_CenterLeft);
			drawText(pos + (4.0 * textScale, getDropdownYOff() + box.size.y * i), fnt, text, textColor, textScale);
		}

		Screen.setClipRect(int(beforeClip.pos.x), int(beforeClip.pos.y), int(beforeClip.size.x), int(beforeClip.size.y));
	}

	bool setSelection() {
		boxparty_AABB dropdownBox; dropdownAABB(dropdownBox);
		if (dropdownBox.pointCollides(master.mousePos)) {
			let diff = master.mousePos - dropdownBox.pos;
			diff /= getScale();
			int newSelection = int(diff.y / box.size.y);
			let fireEvent = selection != newSelection;
			selection = newSelection;
			if (fireEvent && cmdHandler != NULL) {
				cmdHandler.dropdownChanged(self, command);
			}
			return true;
		}
		boxparty_AABB screenBox; boxToScreen(screenBox);
		return screenBox.pointCollides(master.mousePos);
	}

	override bool onUIEventPriority(boxparty_UiEvent ev) {
		if (ev.type == UIEvent.Type_LButtonDown) {
			if (isEnabled()) {
				if (active) {
					active = false;
					return setSelection();
				}
				return false;
			}
		}
		else if (ev.type == UIEvent.Type_LButtonUp && clicking) {
			clicking = false;
			setHoverBlock(NULL);
			boxparty_AABB screenBox; dropdownAABB(screenBox);
			if (active && screenBox.pointCollides(master.mousePos)) {
				active = false;
				return setSelection();
			}
		}
		else if (ev.type == UIEvent.Type_WheelDown || ev.type == UIEvent.Type_WheelUp) {
			active = false;
		}
		return false;
	}

	override bool onUIEvent(boxparty_UiEvent ev) {
		if (ev.type == UIEvent.Type_LButtonDown) {
			if (isEnabled()) {
				boxparty_AABB screenBox; boxToScreen(screenBox);
				if (!active && !ev.mouseBlock && screenBox.pointCollides(master.mousePos)) {
					active = true;
					clicking = true;
					boxparty_AABB dropdownBox; dropdownAABB(dropdownBox);
					if (dropdownBox.pointCollides(master.mousePos)) {
						clicking = false;
					}
					setHoverBlock(self);
				}
			}
		}
		return false;
	}
}
