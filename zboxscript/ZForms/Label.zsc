class boxparty_Label : boxparty_Element {
	Font fnt;
	string text;
	double textScale;
	AlignType alignment;
	int textColor;
	bool wrap;
	bool autoSize;
	double lineSpacing;

	boxparty_Element forElement;
	bool clicking;

	void config(
		string text = "", Font fnt = NULL, AlignType alignment = AlignType_TopLeft, bool wrap = true,
		bool autoSize = false, double textScale = 1, int textColor = Font.CR_WHITE, double lineSpacing = 0,
		boxparty_Element forElement = NULL
	) {
		if (fnt == NULL) {
			self.fnt = smallfont;
		}
		else {
			self.fnt = fnt;
		}
		self.text = text;
		self.alignment = alignment;
		self.wrap = wrap;
		self.autoSize = autoSize;
		self.textScale = textScale;
		self.textColor = textColor;
		self.alpha = 1;
		self.lineSpacing = lineSpacing;
		self.forElement = forElement;
	}

	static boxparty_Label create(
		Vector2 pos, Vector2 size, string text = "", Font fnt = NULL, AlignType alignment = AlignType_TopLeft,
		bool wrap = true, bool autoSize = false, double textScale = 1, int textColor = Font.CR_WHITE,
		double lineSpacing = 0, boxparty_Element forElement = NULL
	) {
		let ret = new('boxparty_Label');

		ret.config(text, fnt, alignment, wrap, autoSize, textScale, textColor, lineSpacing, forElement);
		ret.setBox(pos, size);

		return ret;
	}

	override void ticker() {
		if (autoSize) {
			if (wrap) {
				int fntHeight = fnt.getHeight();
				BrokenLines textLines = fnt.breakLines(text, int(box.size.x / textScale));
				box.size.y = fntHeight * textScale * textLines.count();
			}
			else {
				Array<string> split;
				text.split(split, "\n");
				int fntHeight = fnt.getHeight();
				box.size.y = fntHeight * split.size() * textScale;
				box.size.x = fnt.stringWidth(text) * textScale;
			}
		}
	}

	override void drawer() {
		boxparty_AABB beforeClip, clipRect;
		screenClip(beforeClip, clipRect);
		Screen.setClipRect(int(clipRect.pos.x), int(clipRect.pos.y), int(clipRect.size.x), int(clipRect.size.y));

		if (!wrap) {
			Array<string> split;
			text.split(split, "\n");
			Vector2 pos = getAlignedDrawPos(box.size, (fnt.stringWidth(text), split.size() * fnt.getHeight()) * textScale, alignment);
			drawText(pos, fnt, text, textColor, textScale);
		}
		else {
			int fntHeight = fnt.getHeight();
			float lineHeight = fntHeight + lineSpacing;

			BrokenLines printLines = fnt.breakLines(text, int(box.size.x / textScale));
			Vector2 pos = getAlignedDrawPos(
				box.size,
				(0, (lineHeight * printLines.count() - lineSpacing) * textScale),
				alignment
			);

			for (int i = 0; i < printLines.count(); i++) {
				string line = printLines.stringAt(i);
				Vector2 linePos = getAlignedDrawPos(box.size, (fnt.stringWidth(line) * textScale, 0), alignment);
				drawText((linePos.x, pos.y + (lineHeight * i * textScale)), fnt, line, textColor, textScale);
			}
		}

		Screen.setClipRect(int(beforeClip.pos.x), int(beforeClip.pos.y), int(beforeClip.size.x), int(beforeClip.size.y));
	}

	override bool onUIEvent(boxparty_UiEvent ev) {
		if (forElement == NULL) return false;
		if (ev.type == UIEvent.Type_LButtonDown) {
			boxparty_AABB screenBox; boxToScreen(screenBox);
			if (!ev.mouseBlock && isEnabled() && screenBox.pointCollides(master.mousePos)) {
				clicking = true;
				setHoverBlock(self);
			}
		}
		else if (ev.type == UIEvent.Type_LButtonUp) {
			boxparty_AABB screenBox; boxToScreen(screenBox);
			if (isEnabled() && screenBox.pointCollides(master.mousePos) && clicking) {
				if (forElement.isEnabled()) forElement.activate();
				clicking = false;
				setHoverBlock(NULL);
			}
		}
		return false;
	}
}
